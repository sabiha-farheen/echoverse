

import base64
import io
import json
import os
from dataclasses import dataclass
from typing import Optional, Tuple

import requests
import streamlit as st
from dotenv import load_dotenv

# IBM Watson Text to Speech SDK
from ibm_cloud_sdk_core.authenticators import IAMAuthenticator
from ibm_watson import TextToSpeechV1


# -----------------------------
# Configuration
# -----------------------------
@dataclass
class Settings:
    tts_api_key: str
    tts_url: str
    watsonx_api_key: str
    watsonx_url: str
    watsonx_project_id: str
    watsonx_model_id: str


@st.cache_resource(show_spinner=False)
def get_settings() -> Settings:
    load_dotenv()
    return Settings(
        tts_api_key=os.getenv("WATSON_TTS_API_KEY", ""),
        tts_url=os.getenv("WATSON_TTS_URL", ""),
        watsonx_api_key=os.getenv("WATSONX_API_KEY", ""),
        watsonx_url=os.getenv("WATSONX_URL", ""),
        watsonx_project_id=os.getenv("WATSONX_PROJECT_ID", ""),
        watsonx_model_id=os.getenv("WATSONX_MODEL_ID", "ibm/granite-13b-instruct-v2"),
    )


# -----------------------------
# IBM Watson Text‚Äëto‚ÄëSpeech
# -----------------------------
@st.cache_resource(show_spinner=False)
def get_tts_client(settings: Settings) -> TextToSpeechV1:
    authenticator = IAMAuthenticator(settings.tts_api_key)
    tts = TextToSpeechV1(authenticator=authenticator)
    tts.set_service_url(settings.tts_url)
    return tts


def _wrap_ssml(text: str, speed: float) -> str:
    """Wrap text in SSML to control speaking rate when speed != 1.0."""
    if abs(speed - 1.0) < 1e-3:
        return text
    # IBM TTS supports SSML <prosody rate="x%">; we map 1.0->100%, 0.9->90%, etc.
    rate_pct = int(speed * 100)
    ssml = f"<speak><prosody rate='{rate_pct}%'>{text}</prosody></speak>"
    return ssml


def synthesize_tts_mp3(tts: TextToSpeechV1, text: str, voice: str, speed: float) -> bytes:
    payload = _wrap_ssml(text, speed)
    # If SSML used, Watson TTS auto-detects it by <speak> wrapper
    response = tts.synthesize(
        text=payload,
        voice=voice,
        accept='audio/mp3'
    ).get_result()
    return response.content


# -----------------------------
# IBM watsonx Granite (Text Rewriting)
# -----------------------------

def rewrite_text_via_watsonx(settings: Settings, text: str, style: str, creativity: float) -> Tuple[str, Optional[str]]:
    """
    Call watsonx text generation with a rewrite instruction.
    Returns (rewritten_text, error_message). If error occurs, falls back to local rewrite.
    """
    instruction = (
        "Rewrite the following text for an audiobook narration. "
        f"Style: {style}. Keep meaning intact. Improve clarity and flow."
    )

    prompt = f"{instruction}\n\n---\n{text}\n---\n\nRewritten:"

    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {settings.watsonx_api_key}",
    }

    # NOTE: The endpoint below is a commonly used pattern for IBM ML text generation.
    # Adjust 'version' and path as required by your account/region.
    endpoint = f"{settings.watsonx_url}/ml/v1/text/generation?version=2023-06-01"

    payload = {
        "project_id": settings.watsonx_project_id,
        "model_id": settings.watsonx_model_id,
        "inputs": [
            {
                "input": prompt,
                # Typical generation params; tune as needed
                "parameters": {
                    "decoding_method": "sample",
                    "max_new_tokens": 512,
                    "min_new_tokens": 20,
                    "temperature": max(0.1, min(1.0, creativity)),
                    "top_p": 0.9,
                    "repetition_penalty": 1.05,
                },
            }
        ],
    }

    try:
        r = requests.post(endpoint, headers=headers, data=json.dumps(payload), timeout=60)
        r.raise_for_status()
        data = r.json()
        # Response shape may vary. Try a few common patterns safely.
        rewritten = None
        # Pattern A: { results: [ { generated_text: "..." } ] }
        if isinstance(data, dict):
            results = data.get("results") or data.get("generated_text")
            if isinstance(results, list) and results:
                first = results[0]
                rewritten = first.get("generated_text") or first.get("text")
            elif isinstance(results, str):
                rewritten = results
            # Pattern B: { outputs: [ { text: "..." } ] }
            if rewritten is None:
                outputs = data.get("outputs")
                if isinstance(outputs, list) and outputs:
                    rewritten = outputs[0].get("text")

        if not rewritten:
            raise ValueError("Unexpected watsonx response format")

        return rewritten.strip(), None

    except Exception as e:
        # Fallback: very simple local rewrite so the app still functions
        fallback = simple_local_rewrite(text, style)
        return fallback, f"Granite call failed; using local rewrite. Reason: {e}"


def simple_local_rewrite(text: str, style: str) -> str:
    """Naive local rewrite as a graceful fallback."""
    # Trim, normalize whitespace, add light style touches
    lines = [ln.strip() for ln in text.splitlines()]
    compact = " ".join([ln for ln in lines if ln])
    if style.lower().startswith("convers"):
        prefix = "Let me tell you a story: "
    elif style.lower().startswith("formal"):
        prefix = "In summary, "
    else:
        prefix = ""  # neutral
    return (prefix + compact).strip()


# -----------------------------
# Streamlit UI
# -----------------------------

def ui_header():
    st.set_page_config(page_title="EchoVerse ‚Ä¢ AI Audiobook Tool", page_icon="üéß")
    st.title("üéß EchoVerse: AI‚Äëpowered Audiobook Creator")
    st.caption("Streamlit ‚Ä¢ IBM watsonx Granite ‚Ä¢ IBM Watson Text‚Äëto‚ÄëSpeech")


def ui_sidebar(settings: Settings) -> dict:
    st.sidebar.header("Configuration")

    voice = st.sidebar.selectbox(
        "TTS Voice",
        options=[
            "en-US_AllisonV3Voice",
            "en-US_MichaelV3Voice",
            "en-GB_KateV3Voice",
            "en-US_LisaV3Voice",
            "en-AU_CraigVoice",
        ],
        index=0,
    )

    speed = st.sidebar.slider("Speech speed", min_value=0.7, max_value=1.3, value=1.0, step=0.05)

    style = st.sidebar.selectbox(
        "Rewrite style",
        options=["Conversational", "Narrative", "Formal", "Engaging", "Neutral"],
        index=1,
    )

    creativity = st.sidebar.slider("Creativity (temperature)", 0.1, 1.0, 0.6, 0.05)

    st.sidebar.divider()
    with st.sidebar.expander("Credentials status", expanded=False):
        def s(pass_bool):
            return "‚úÖ" if pass_bool else "‚ö†Ô∏è"
        st.write(f"TTS key: {s(bool(settings.tts_api_key))}")
        st.write(f"TTS url: {s(bool(settings.tts_url))}")
        st.write(f"watsonx key: {s(bool(settings.watsonx_api_key))}")
        st.write(f"watsonx url: {s(bool(settings.watsonx_url))}")
        st.write(f"Project ID: {s(bool(settings.watsonx_project_id))}")

    return {
        "voice": voice,
        "speed": float(speed),
        "style": style,
        "creativity": float(creativity),
    }


def ui_main(settings: Settings, cfg: dict):
    st.subheader("1) Provide your content")
    default_txt = (
        "Chapter 1\n\n" \
        "The rain fell in silver threads, and the city listened. "
        "Our story begins with a letter that arrived too late."
    )

    uploaded = st.file_uploader("Upload a .txt manuscript (optional)", type=["txt"], help="Plain text only")
    text_in = st.text_area("Or paste text here", height=240, value=default_txt)

    if uploaded is not None:
        try:
            text_in = uploaded.read().decode("utf-8", errors="ignore")
        except Exception:
            st.warning("Could not read the uploaded file as UTF‚Äë8. Using the text area content instead.")

    st.subheader("2) Rewrite (Granite) ‚Üí Narrate (Watson TTS)")
    go = st.button("Rewrite & Generate Audio", type="primary")

    if go:
        if not text_in.strip():
            st.error("Please provide some input text.")
            return

        with st.spinner("Rewriting with IBM watsonx Granite..."):
            rewritten, err = rewrite_text_via_watsonx(get_settings(), text_in.strip(), cfg["style"], cfg["creativity"])
        if err:
            st.info(err)

        st.text_area("Rewritten text", value=rewritten, height=220)

        st.write("\n**Generating speech (MP3) with IBM Watson Text‚Äëto‚ÄëSpeech...**")
        try:
            mp3_bytes = synthesize_tts_mp3(get_tts_client(get_settings()), rewritten, cfg["voice"], cfg["speed"])
        except Exception as e:
            st.error(f"TTS synthesis failed: {e}")
            return

        # Audio playback
        st.audio(mp3_bytes, format="audio/mp3")

        # Download button
        st.download_button(
            label="Download MP3",
            data=mp3_bytes,
            file_name="echoverse_output.mp3",
            mime="audio/mpeg",
        )

        # Small success note
        st.success("Done! Preview the audio above or download the MP3.")


# -----------------------------
# Entrypoint
# -----------------------------
if __name__ == "__main__":
    settings = get_settings()
    ui_header()
    cfg = ui_sidebar(settings)
    ui_main(settings, cfg)
